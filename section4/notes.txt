================================================================================
Controllers and Actions
================================================================================

--------------------------------------------------------------------------------
Controllers and Actions: An Introduction
--------------------------------------------------------------------------------

- Controllers are what the user interacts with
- They receive a request from the user, decide what to do, then send a response back

- The router has matched a url to a route to get a controller and action
- Controllers are PHP Classes
- They contain methods that are the actions

--------------------------------------------------------------------------------
How to Create Objects and Run Methods Dynamically
--------------------------------------------------------------------------------

- To create a new object:
    - $post = new Post();
- Create an object based on variable:
    - $class_name = "Post";
    - $post = new $class_name();

- To call a method:
    - $post = new Post();
    - $post->save();
- To call a method based on a variable
    - $method = "save";
    - $post->$method();

- To call a mthod and pass parameters to it:
    - $post = new Post();
    - call_user_func_array([$post, "save"], [123, "abc"]);

- To check if the class exists before creating an object:
    - $class_name = "Post";
    - if (class_exists($class_name)) {
        $post = new $class_name();
    }

- To check if a method exists and is public
    - $post = new Post();
    - $method = "save";
    - if (is_callable([$post, $method])) {
        $post->$method();
    }

--------------------------------------------------------------------------------
Dispatch the Route: Create the Controller Object and Run the Action Method
--------------------------------------------------------------------------------

= Dispatching
    - Routing - asking for directions
    - Dispatching - following those directions
- The dispatching step is going to create a controller object and run the action method

- Route will provide a controller parameter
- Words separated in URL by hyphens
- Controller classes named using StudlyCaps (I think he means UpperCamelCase) (PSR-1)

= Route => Parameter => Class
/posts/index => posts => Posts
/products/add-new => products => Products
/post-authors/list => post-authors => PostAuthors

- Router will provide an action parameter
- Words in URL separated by hyphens
- Action methods named using lowerCamelCase (camelCase)

= Route => Parameter => Method Name
/posts/index => index => index
/products/add-new => add-new => addNew
/post-authors/list => list => list

= Must convery parameters to classes and methods

--------------------------------------------------------------------------------
How to Better Organise Your Classes By Using Namespaces
--------------------------------------------------------------------------------

= Unique Class Names
- In the same way that you can't have two files with the same name in the same folder
    - You can't have two classes with the same name in a PHP script

= Class Name Collisions
Having two (or more) classes with the same name?
- You want to create a class with the same name as an existing class (DateTime)
- You're using a library that has classes with the same name as your classes
- You have lots of classes and want to organize them (organizing files in directories)

= Namespaces
- Like a folder or directory
- Defined with the namespace keyword
- Allows you to have two (or more) classes with the same name
- The name can be anything you like

- Can be nested like folders
- Separated with a backslash
- As many levels as you like

- PHP looks for classes relative to the current namespace
    - to look for classes in another namespace, you need to add a backslash

- `use` keyword imports the class into the current namespace
    - `use App\Core\Lib\Models\Product;`
    - `$product = new Product();`

- Can also alias the imported class as:
    - `use App\Core\Lib\Models\Product as CoreProduct;`
    - `$product = new CoreProduct();`

--------------------------------------------------------------------------------
Class Autoloading: Load Classes Automatically without Require
--------------------------------------------------------------------------------

- Common practice to define each class in a separate file
- Before you can use a class defined in a separate file, you have to require the file
    - Can end up with a long list of requires

- PHP can load class files automatically on demand with an autoload function
- If the class doesn't exist, we can run the autoload function, then check if it exists

- To add an autoload function, use spl_autoload_register, passing in a function that
    will run when the autoloader is needed

- Each class in a separate file
- The filename matching the class name
- In folders that match the namespaces
==>
- Classes will be automatically required on demand
- No explicit require statements are required

--------------------------------------------------------------------------------
Load Classes Automatically: Add Namespaces to an Autoload Function
--------------------------------------------------------------------------------

= Adding the autoload function
- We want to require class files relative to the root of the site
- The front controller (index.php) is in the public folder
- The root folder is the parent directory of the public folder

--------------------------------------------------------------------------------
Remove Query String Variables From the URL Before Matching to a Route
--------------------------------------------------------------------------------

- Didn't add handling to remove query string yet

--------------------------------------------------------------------------------
Pass Route Parameters from the Route to all Contollers
--------------------------------------------------------------------------------

- We made a route like /{controller}/{id}/{actions}
- We need to be able to access this id in any controller
    - Create a base controller class to do this

--------------------------------------------------------------------------------
The __call magic method, how to call inaccessable methods in a class
--------------------------------------------------------------------------------

- A class can have many methods
- Public methods can be run on objects of that class
    - protected and private methods are not available from outside the class
- Is there a way to access them anyways?
    - __call is a php magic method
    - Called whenever a non-existent or non-public method is called on an object
    - The method is passed the method name and arguments
    - Can be called from inside the __call method using call_user_func_array

--------------------------------------------------------------------------------
Action Filters: Call a method before and after every action in a controller
--------------------------------------------------------------------------------

- A controller can have many actions
- Actions will generally:
    - Write out content
    - Redirect to another action
    - Etc.
= How to execute some code before and after every action?
- Checking the user has logged in
- Writing a message to a log
- Setting the language, etc.

By executing __call first, we can run code before and after a method

1: Make all controller methods private
2: Add a suffix to the method name

Any actions need to have an "Action" suffix

--------------------------------------------------------------------------------
Organise controllers in subdirectories: Add a Route Namespace Option
--------------------------------------------------------------------------------

- Can't have subdiretories of controllers with the way we set it up
- Routes with namespaces
    - Option to specify the namespace in the route
    - Defaults to App\Controllers if not specified